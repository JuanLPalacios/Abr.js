{"version":3,"file":"abr.esm.js","sources":["../node_modules/sequential-data-view-js/src/sequential-data-view.ts","../src/abr.ts"],"sourcesContent":["export class SequentialDataView {\r\n    dataView: DataView;\r\n    offset: number;\r\n\r\n    constructor(arrayBuffer: ArrayBuffer) {\r\n        this.dataView = new DataView(arrayBuffer);\r\n        this.offset = 0;\r\n    }\r\n\r\n    readRawData(buffer: number[], length: number): number {\r\n        while (buffer.length > 0) buffer.pop();\r\n        const pos = this.offset;\r\n        const endPos = this.offset + length;\r\n        while ((!this.atEnd()) && (this.offset < endPos)) {\r\n            buffer.push(this.getUint8());\r\n        }\r\n        return this.offset - pos;\r\n    }\r\n    data() {\r\n        return this.dataView.buffer;\r\n    }\r\n    getPos(): number {\r\n        return this.offset;\r\n    }\r\n    setPos(offset: number) {\r\n        this.offset = offset;\r\n    }\r\n    size(): number {\r\n        return this.dataView.byteLength;\r\n    }\r\n    atEnd(): boolean {\r\n        return this.offset >= this.dataView.byteLength;\r\n    }\r\n    getUint8(): number {\r\n        const pos = this.offset;\r\n        this.offset += 1;\r\n        return this.dataView.getUint8(pos);\r\n    }\r\n    getUint16(): number {\r\n        const pos = this.offset;\r\n        this.offset += 2;\r\n        return this.dataView.getUint16(pos);\r\n    }\r\n    getUint32(): number {\r\n        const pos = this.offset;\r\n        this.offset += 4;\r\n        return this.dataView.getUint32(pos);\r\n    }\r\n    getInt16() {\r\n        const pos = this.offset;\r\n        this.offset += 2;\r\n        return this.dataView.getInt16(pos);\r\n    }\r\n    getChar(): string {\r\n        return String.fromCharCode(this.getUint8());\r\n    }\r\n}\r\n","/*\r\n *  SPDX-FileCopyrightText: 2010 Boudewijn Rempt <boud@valdyas.org>\r\n *  SPDX-FileCopyrightText: 2010 Lukáš Tvrdý <lukast.dev@gmail.com>\r\n *  SPDX-FileCopyrightText: 2007 Eric Lamarque <eric.lamarque@free.fr>\r\n *  SPDX-FileCopyrightText: 2024 Juan Luis Palacios Pérez <juan.luis.palacios.p@gmail.com>\r\n *\r\n *  SPDX-License-Identifier: GPL-2.0-or-later\r\n */\r\n\r\nimport { SequentialDataView } from \"sequential-data-view-js\";\r\n\r\nexport const INT16_MAX = 65535;\r\n// FIXME: this needs to be not empty\r\nconst defaultBrushTipImage = document.createElement('canvas');\r\n\r\nexport const abrBrushes = {\r\n    map: <{ [key: string]: AbrBrush; }>{},\r\n    get(key: string): AbrBrush {\r\n        return this.map[key];\r\n    },\r\n    set(key: string, value: AbrBrush) {\r\n        this.map[key] = value;\r\n    },\r\n    clear() {\r\n        this.map = {};\r\n    },\r\n    list() {\r\n        return Object.values(this.map);\r\n    }\r\n};\r\n\r\nfunction getDefaultSampledBrush(name: string): AbrSampledBrush {\r\n    return { brushType: 2, brushTipImage: defaultBrushTipImage, md5Sum: new ArrayBuffer(0), name, valid: false, spacing: 1, antiAliasing: true };\r\n}\r\n\r\nexport async function loadAbrBrushes(file: File) {\r\n    const buffer:ArrayBuffer = await (new Promise((resolve, reject) => {\r\n        const fileReader = new FileReader();\r\n        fileReader.onload = function(event) {\r\n            if(event.target&&event.target.result&&(typeof event.target.result != 'string')) resolve(event.target.result);\r\n            else reject();\r\n        };\r\n        fileReader.readAsArrayBuffer(file);\r\n    }));\r\n    return loadAbrFromArrayBuffer(buffer, file.name);\r\n}\r\n\r\nexport async function loadAbrFromArrayBuffer(buffer: ArrayBuffer, filename:string) {\r\n    const abrSdv = new SequentialDataView(buffer);\r\n    try {\r\n        const abrHeader:AbrHeader = abrReadContent(abrSdv);\r\n        if (!abrSupportedContent(abrHeader)) {\r\n            throw new Error(`ERROR: unable to decode abr format version ${abrHeader.version}(subver ${abrHeader.subversion})`);\r\n        }\r\n        if (abrHeader.count == 0) {\r\n            throw new Error(`ERROR: no brushes found in ${filename}`);\r\n        }\r\n        const imageId = 123456;\r\n        for (let i = 0; i < abrHeader.count; i++) {\r\n            const layerId = await loadAbrBrush(abrSdv, abrHeader, filename, imageId, i + 1);\r\n            if (layerId == -1) {\r\n                console.warn(`Warning: problem loading brush #${i} in ${filename}`);\r\n            }\r\n        }\r\n        const brushes = abrBrushes.list();\r\n        abrBrushes.clear();\r\n        return brushes;\r\n    } catch (error) {\r\n        console.error(error)\r\n        throw new Error(`Error: cannot parse ABR file: ${filename}`);\r\n    }\r\n}\r\n\r\nexport const abrReadContent=(abrSdv:SequentialDataView):AbrHeader=>{\r\n    const abrHeader:AbrHeader = { count: 0, subversion: 0, version: 0 };\r\n    abrHeader.version = abrSdv.getUint16();\r\n    abrHeader.subversion = 0;\r\n    abrHeader.count = 0;\r\n\r\n    switch (abrHeader.version) {\r\n    case 1:\r\n    case 2:\r\n        // ver:1-2\r\n        abrHeader.count = abrSdv.getUint16();\r\n        break;\r\n    case 6:\r\n        // ver:6\r\n        abrHeader.subversion = abrSdv.getUint16();\r\n        abrHeader.count = findSampleCountV6(abrSdv, abrHeader);\r\n        break;\r\n    default:\r\n        // unknown versions\r\n        break;\r\n    }\r\n\r\n    // next bytes in abr are samples data\r\n    return abrHeader;\r\n};\r\n\r\nfunction findSampleCountV6(abrSdv: SequentialDataView, abrHeader: AbrHeader): number {\r\n    let brushSize:number;\r\n    let brushEnd:number;\r\n\r\n    if (!abrSupportedContent(abrHeader))\r\n        return 0;\r\n    const origin = abrSdv.getPos();\r\n    try {\r\n        abrReach8BimSection(abrSdv, 'samp');\r\n    } catch (error) {\r\n        abrSdv.setPos(origin);\r\n        return 0;\r\n    }\r\n    // long\r\n    const sampleSectionSize = abrSdv.getUint32();\r\n    const sampleSectionEnd = sampleSectionSize + abrSdv.getPos();\r\n    if(sampleSectionEnd < 0 || sampleSectionEnd > abrSdv.size())\r\n        return 0;\r\n    const dataStart = abrSdv.getPos();\r\n    let samples = 0;\r\n    while ((!abrSdv.atEnd()) && (abrSdv.getPos() < sampleSectionEnd)) {\r\n        // read long\r\n        brushSize = abrSdv.getUint32();\r\n        brushEnd = brushSize;\r\n        // complement to 4\r\n        while (brushEnd % 4 != 0) brushEnd++;\r\n        const newPos = abrSdv.getPos() + brushEnd;\r\n        if(newPos > 0 && newPos < abrSdv.size()) {\r\n            abrSdv.setPos(newPos);\r\n        }\r\n        else\r\n            return 0;\r\n        samples++;\r\n    }\r\n    // set StreamDataViewer to samples data\r\n    abrSdv.setPos(dataStart);\r\n    return samples;\r\n}\r\n\r\nexport function abrSupportedContent(abrHeader: AbrHeader): boolean {\r\n    switch (abrHeader.version) {\r\n    case 1:\r\n    case 2:\r\n        return true;\r\n    case 6:\r\n        if (abrHeader.subversion == 1 || abrHeader.subversion == 2)\r\n            return true;\r\n        break;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport function abrReach8BimSection(abrSdv: SequentialDataView, name: string):void {\r\n    let sectionSize = 0;\r\n    // find 8BIMname section\r\n    while (!abrSdv.atEnd()) {\r\n        const tag: number[] = [];\r\n        const tagname: number[] = [];\r\n        let r;\r\n        r = abrSdv.readRawData(tag, 4);\r\n        if (r != 4) {\r\n            throw new Error('Error: Cannot read 8BIM tag ');\r\n        }\r\n        if (charCodeComparison(tag, '8BIM', 4)) {\r\n            throw new Error(`Error: Start tag not 8BIM but ${String.fromCharCode(...tag)} at position ${abrSdv.getPos()}`);\r\n        }\r\n        r = abrSdv.readRawData(tagname, 4);\r\n        if (r != 4) {\r\n            throw new Error('Error: Cannot read 8BIM tag name');\r\n        }\r\n        const s1: string = String.fromCharCode(...tagname);\r\n        if (s1 == name) {\r\n            return;\r\n        }\r\n        // long\r\n        sectionSize = abrSdv.getUint32();\r\n        abrSdv.setPos(abrSdv.getPos() + sectionSize);\r\n    }\r\n    return;\r\n}\r\n\r\nexport function charCodeComparison(buffer: number[], str: string, num: number): boolean {\r\n    if ((buffer.length < num) || (str.length < num)) return true;\r\n    for (let i = 0; i < num; i++) {\r\n        if (str.charCodeAt(i) !== buffer[i]) return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport async function loadAbrBrush(abrSdv: SequentialDataView, abrHeader: AbrHeader, filename: string, imageId: number, id: number){\r\n    let layerId = -1;\r\n    switch (abrHeader.version) {\r\n    case 1:\r\n        // fall through, version 1 and 2 are compatible\r\n    case 2:\r\n        layerId = await loadAbrBrushV12(abrSdv, abrHeader, filename, imageId, id);\r\n        break;\r\n    case 6:\r\n        layerId = await loadAbrBrushV6(abrSdv, abrHeader, filename, imageId, id);\r\n        break;\r\n    }\r\n    return layerId;\r\n}\r\n\r\nasync function loadAbrBrushV6(abrSdv: SequentialDataView, abrHeader: AbrHeader, filename: string, imageId: number, id: number): Promise<number> {\r\n    let brushSize = 0;\r\n    let brushEnd = 0;\r\n    let layerId = -1;\r\n\r\n    brushSize = abrSdv.getUint32();\r\n    brushEnd = brushSize;\r\n    // complement to 4\r\n    while (brushEnd % 4 != 0) {\r\n        brushEnd++;\r\n    }\r\n    const nextBrush = abrSdv.getPos() + brushEnd;\r\n    // discard key\r\n    abrSdv.setPos(abrSdv.getPos() + 37);\r\n    if (abrHeader.subversion == 1)\r\n        // discard short coordinates and unknown short\r\n        abrSdv.setPos(abrSdv.getPos() + 10);\r\n    else {\r\n        // discard unknown bytes\r\n        abrSdv.setPos(abrSdv.getPos() + 264);\r\n    }\r\n    // long bounds\r\n    const top = abrSdv.getUint32();\r\n    const left = abrSdv.getUint32();\r\n    const bottom = abrSdv.getUint32();\r\n    const right = abrSdv.getUint32();\r\n    // short\r\n    const depth = abrSdv.getUint16();\r\n    // char\r\n    const compression = abrSdv.getUint8();\r\n    const width = right - left;\r\n    const height = bottom - top;\r\n    const size = width * (depth >> 3) * height;\r\n    // remove .abr and add some id, so something like test.abr . test_12345\r\n    const name: string = abrV1BrushName(filename, id);\r\n    const buffer:number[] = [];\r\n    // data decoding\r\n    if (!compression) {\r\n        // not compressed - read raw bytes as brush data\r\n        abrSdv.readRawData(buffer, size);\r\n    } else {\r\n        rleDecode(abrSdv, buffer, height);\r\n    }\r\n    if (width < INT16_MAX && height < INT16_MAX) {\r\n        // [filename]_[test number of the brush], e.g test_1, test_2\r\n        let abrBrush: AbrSampledBrush;\r\n        const brushTipImage = convertCanvas(buffer, width, height);\r\n        if (Object.keys(abrBrushes.map).includes(name)) {\r\n            abrBrush = getDefaultSampledBrush(name);\r\n        }\r\n        else {\r\n            abrBrush = getDefaultSampledBrush(name);\r\n            const buf = new SequentialDataView(new ArrayBuffer(0));\r\n            abrBrush = { ...abrBrush, md5Sum: await crypto.subtle.digest('SHA-256', buf.data()) };\r\n        }\r\n        abrBrush = { ...abrBrush, brushTipImage };\r\n        abrBrush = { ...abrBrush, valid: true };\r\n        abrBrush = { ...abrBrush, name };\r\n        abrBrushes.set(name, abrBrush);\r\n    }\r\n    abrSdv.setPos(nextBrush);\r\n    layerId = id;\r\n    return layerId;\r\n}\r\n\r\nasync function loadAbrBrushV12(abrSdv: SequentialDataView, abrHeader: AbrHeader, filename: string, imageId: number, id: number): Promise<number> {\r\n    let name = '';\r\n    let layerId = -1;\r\n\r\n    // short\r\n    const brushType = abrSdv.getUint16();\r\n    // long\r\n    const brushSize = abrSdv.getUint32();\r\n    const nextBrush = abrSdv.getPos() + brushSize;\r\n    if (brushType == 1) {\r\n        // computed brush\r\n        abrSdv.setPos(abrSdv.getPos() + 4); //miscellaneous Long integer. Ignored\r\n        const spacing = abrSdv.getUint16(); // 2 bytes Short integer from 0...999 where 0=no spacing.\r\n        const diameter = abrSdv.getUint16(); // 2 bytes Short integer from 1...999.\r\n        const roundness = abrSdv.getUint16(); // 2 bytes Short integer from 0...100.\r\n        const angle = abrSdv.getInt16(); // 2 bytes Short integer from -180...180.\r\n        const hardness = abrSdv.getUint16(); // 2 bytes Short integer from 0...100.\r\n        name = abrV1BrushName(filename, id);\r\n        abrBrushes.set(name, { brushType: brushType, spacing, diameter, roundness, angle, hardness, name });\r\n        abrSdv.setPos(nextBrush);\r\n        layerId = 1;\r\n    }\r\n    else if (brushType == 2) {\r\n        // sampled brush\r\n        // discard 4 misc bytes\r\n        abrSdv.setPos(abrSdv.getPos() + 4);\r\n        const spacing = abrSdv.getUint16();\r\n        if (abrHeader.version == 2)\r\n            name = readAbrUcs2Text(abrSdv);\r\n        if (name === null) {\r\n            name = abrV1BrushName(filename, id);\r\n        }\r\n        const antiAliasing = !!abrSdv.getUint8();\r\n        // discard 4 short for short bounds\r\n        abrSdv.setPos(abrSdv.getPos() + 8);\r\n        // long bounds\r\n        const top = abrSdv.getUint32();\r\n        const left = abrSdv.getUint32();\r\n        const bottom = abrSdv.getUint32();\r\n        const right = abrSdv.getUint32();\r\n        // short\r\n        const depth = abrSdv.getUint16();\r\n        // char\r\n        const compression = abrSdv.getUint8();\r\n        const width = right - left;\r\n        const height = bottom - top;\r\n        const size = width * (depth >> 3) * height;\r\n        // FIXME: support wide brushes\r\n        if (height > 16384) {\r\n            console.warn('WARNING: wide brushes not supported');\r\n            abrSdv.setPos(nextBrush);\r\n        }\r\n        else {\r\n            const buffer: number[] = [];\r\n            if (!compression) {\r\n                // not compressed - read raw bytes as brush data\r\n                abrSdv.readRawData(buffer, size);\r\n            } else {\r\n                rleDecode(abrSdv, buffer, height);\r\n            }\r\n            let abrBrush: AbrSampledBrush;\r\n            const brushTipImage = convertCanvas(buffer, width, height);\r\n            if (Object.keys(abrBrushes.map).includes(name)) {\r\n                abrBrush = getDefaultSampledBrush(name);\r\n            }\r\n            else {\r\n                abrBrush = getDefaultSampledBrush(name);\r\n                const buf = new SequentialDataView(new ArrayBuffer(0));\r\n                // FIXME: it should use a slice containing the brush sample to be useful\r\n                abrBrush = { ...abrBrush, md5Sum: await crypto.subtle.digest('SHA-256', buf.data()) };\r\n            }\r\n            abrBrush = { ...abrBrush, brushTipImage };\r\n            abrBrush = { ...abrBrush, valid: true };\r\n            abrBrush = { ...abrBrush, name, spacing, antiAliasing };\r\n            abrBrushes.set(name, abrBrush);\r\n            layerId = 1;\r\n        }\r\n    }\r\n    else {\r\n        console.warn('Unknown ABR brush type, skipping.');\r\n        abrSdv.setPos(nextBrush);\r\n    }\r\n    return layerId;\r\n}\r\n\r\nfunction abrV1BrushName(filename: string, id: number): string {\r\n    const result = filename.split('');\r\n    const pos = filename.lastIndexOf('.');\r\n    result.splice(pos, 4);\r\n    return result.join('') + '_' + id;\r\n}\r\n\r\nfunction rleDecode(abrSdv: SequentialDataView, data: number[], height: number) {\r\n    // read compressed size foreach scan line\r\n    const scanLines = Array.from({ length: height }, () => 0);\r\n    for (let i = 0; i < height; i++) {\r\n        // short\r\n        scanLines[i] = abrSdv.getUint16();\r\n    }\r\n    // unpack each scan line data\r\n    for (let i = 0; i < height; i++) {\r\n        for (let j = 0; j < scanLines[i];) {\r\n            // char\r\n            if (abrSdv.atEnd()) {\r\n                break;\r\n            }\r\n            let n = abrSdv.getUint8();\r\n            j++;\r\n            if (n >= 128) // force sign\r\n                n -= 256;\r\n            if (n < 0) { // copy the following char -n + 1 times\r\n                if (n == -128) // it's a nop\r\n                    continue;\r\n                n = -n + 1;\r\n                // char\r\n                const ch = abrSdv.getUint8();\r\n                if (abrSdv.atEnd()) {\r\n                    break;\r\n                }\r\n                j++;\r\n                for (let k = 0; k < n; k++) {\r\n                    data.push(ch);\r\n                }\r\n            }\r\n            else {\r\n                // read the following n + 1 chars (no compr)\r\n                for (let c = 0; c < n + 1; c++, j++) {\r\n                    // char\r\n                    const ct = abrSdv.getUint8();\r\n                    data.push(ct);\r\n                    //data.pos++;\r\n                    if (abrSdv.atEnd()) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction convertCanvas(buffer: number[], width: number, height: number): HTMLCanvasElement {\r\n    const img = document.createElement('canvas');\r\n    img.width = width;\r\n    img.height = height;\r\n    const ctx = img.getContext('2d');\r\n    if (!ctx) throw new Error('Failed to construct context.');\r\n    const pixel = ctx.getImageData(0, 0, width, height);\r\n    let pos = 0;\r\n    let value = 0;\r\n    for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++, pos++) {\r\n            value = 255 - buffer[pos];\r\n            for (let i = 0; i < 3; i++) {\r\n                pixel.data[y * width * 4 + x * 4 + i] = value;\r\n            }\r\n            pixel.data[y * width * 4 + x * 4 + 3] = 255;\r\n        }\r\n    }\r\n    ctx.putImageData(pixel, 0, 0);\r\n    return img;\r\n}\r\n\r\nfunction readAbrUcs2Text(abrSdv: SequentialDataView): string {\r\n    let i: number;\r\n    /* two-bytes characters encoded (UCS-2)\r\n    *  format:\r\n    *   long : size - number of characters in string\r\n    *   data : zero terminated UCS-2 string\r\n    */\r\n    // long\r\n    const nameSize = abrSdv.getUint32();\r\n    if (nameSize == 0) {\r\n        return '';\r\n    }\r\n    const bufSize = nameSize;\r\n    const nameUcs2: number[] = [];\r\n    for (i = 0; i < bufSize; i++) {\r\n        //* char*/\r\n        // I will use uint16 as that is input to fromUtf16\r\n        nameUcs2[i] = abrSdv.getUint16();\r\n    }\r\n    const nameUtf8 = String.fromCharCode(...nameUcs2);\r\n    return nameUtf8;\r\n}"],"names":["SequentialDataView","constructor","arrayBuffer","this","dataView","DataView","offset","readRawData","buffer","length","pop","pos","endPos","atEnd","push","getUint8","data","getPos","setPos","size","byteLength","getUint16","getUint32","getInt16","getChar","String","fromCharCode","INT16_MAX","defaultBrushTipImage","document","createElement","abrBrushes","map","get","key","set","value","clear","list","Object","values","getDefaultSampledBrush","name","brushType","brushTipImage","md5Sum","ArrayBuffer","valid","spacing","antiAliasing","loadAbrBrushes","file","loadAbrFromArrayBuffer","Promise","resolve","reject","fileReader","FileReader","onload","event","target","result","readAsArrayBuffer","filename","abrSdv","abrHeader","abrReadContent","abrSupportedContent","Error","version","subversion","count","imageId","i","loadAbrBrush","console","warn","brushes","error","brushSize","brushEnd","origin","abrReach8BimSection","sampleSectionSize","sampleSectionEnd","dataStart","samples","newPos","findSampleCountV6","sectionSize","tag","tagname","r","charCodeComparison","str","num","charCodeAt","id","layerId","nextBrush","diameter","roundness","angle","hardness","abrV1BrushName","nameSize","bufSize","nameUcs2","readAbrUcs2Text","top","left","bottom","right","depth","compression","width","height","abrBrush","rleDecode","convertCanvas","keys","includes","buf","assign","crypto","subtle","digest","loadAbrBrushV12","loadAbrBrushV6","split","lastIndexOf","splice","join","scanLines","Array","from","j","n","ch","k","c","ct","img","ctx","getContext","pixel","getImageData","y","x","putImageData"],"mappings":"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"}