{"version":3,"file":"dist/abr.js","mappings":"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","sources":["webpack://abr/webpack/universalModuleDefinition","webpack://abr/webpack/bootstrap","webpack://abr/webpack/runtime/define property getters","webpack://abr/webpack/runtime/hasOwnProperty shorthand","webpack://abr/webpack/runtime/make namespace object","webpack://abr/./node_modules/sequential-data-view-js/dist/sequential-data-view.esm.js","webpack://abr/./src/abr.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"abr\"] = factory();\n\telse\n\t\troot[\"abr\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","class t{constructor(t){this.dataView=new DataView(t),this.offset=0}readRawData(t,s){for(;t.length>0;)t.pop();const i=this.offset,h=this.offset+s;for(;!this.atEnd()&&this.offset<h;)t.push(this.getUint8());return this.offset-i}data(){return this.dataView.buffer}getPos(){return this.offset}setPos(t){this.offset=t}size(){return this.dataView.byteLength}atEnd(){return this.offset>=this.dataView.byteLength}getUint8(){const t=this.offset;return this.offset+=1,this.dataView.getUint8(t)}getUint16(){const t=this.offset;return this.offset+=2,this.dataView.getUint16(t)}getUint32(){const t=this.offset;return this.offset+=4,this.dataView.getUint32(t)}getInt16(){const t=this.offset;return this.offset+=2,this.dataView.getInt16(t)}getChar(){return String.fromCharCode(this.getUint8())}}export{t as SequentialDataView};\n//# sourceMappingURL=sequential-data-view.esm.js.map\n","/*\r\n *  SPDX-FileCopyrightText: 2010 Boudewijn Rempt <boud@valdyas.org>\r\n *  SPDX-FileCopyrightText: 2010 Lukáš Tvrdý <lukast.dev@gmail.com>\r\n *  SPDX-FileCopyrightText: 2007 Eric Lamarque <eric.lamarque@free.fr>\r\n *  SPDX-FileCopyrightText: 2024 Juan Luis Palacios Pérez <juan.luis.palacios.p@gmail.com>\r\n *\r\n *  SPDX-License-Identifier: GPL-2.0-or-later\r\n */\r\n\r\nimport { SequentialDataView } from \"sequential-data-view-js\";\r\n\r\nexport const INT16_MAX = 65535;\r\n// FIXME: this needs to be not empty\r\nconst defaultBrushTipImage = document.createElement('canvas');\r\n\r\nexport const abrBrushes = {\r\n    map: <{ [key: string]: AbrBrush; }>{},\r\n    get(key: string): AbrBrush {\r\n        return this.map[key];\r\n    },\r\n    set(key: string, value: AbrBrush) {\r\n        this.map[key] = value;\r\n    },\r\n    clear() {\r\n        this.map = {};\r\n    },\r\n    list() {\r\n        return Object.values(this.map);\r\n    }\r\n};\r\n\r\nfunction getDefaultSampledBrush(name: string): AbrSampledBrush {\r\n    return { brushType: 2, brushTipImage: defaultBrushTipImage, md5Sum: new ArrayBuffer(0), name, valid: false, spacing: 1, antiAliasing: true };\r\n}\r\n\r\nexport async function loadAbrBrushes(file: File) {\r\n    const buffer:ArrayBuffer = await (new Promise((resolve, reject) => {\r\n        const fileReader = new FileReader();\r\n        fileReader.onload = function(event) {\r\n            if(event.target&&event.target.result&&(typeof event.target.result != 'string')) resolve(event.target.result);\r\n            else reject();\r\n        };\r\n        fileReader.readAsArrayBuffer(file);\r\n    }));\r\n    return loadAbrFromArrayBuffer(buffer, file.name);\r\n}\r\n\r\nexport async function loadAbrFromArrayBuffer(buffer: ArrayBuffer, filename:string) {\r\n    const abrSdv = new SequentialDataView(buffer);\r\n    try {\r\n        const abrHeader:AbrHeader = abrReadContent(abrSdv);\r\n        if (!abrSupportedContent(abrHeader)) {\r\n            throw new Error(`ERROR: unable to decode abr format version ${abrHeader.version}(subver ${abrHeader.subversion})`);\r\n        }\r\n        if (abrHeader.count == 0) {\r\n            throw new Error(`ERROR: no brushes found in ${filename}`);\r\n        }\r\n        const imageId = 123456;\r\n        for (let i = 0; i < abrHeader.count; i++) {\r\n            const layerId = await loadAbrBrush(abrSdv, abrHeader, filename, imageId, i + 1);\r\n            if (layerId == -1) {\r\n                console.warn(`Warning: problem loading brush #${i} in ${filename}`);\r\n            }\r\n        }\r\n        const brushes = abrBrushes.list();\r\n        abrBrushes.clear();\r\n        return brushes;\r\n    } catch (error) {\r\n        console.error(error)\r\n        throw new Error(`Error: cannot parse ABR file: ${filename}`);\r\n    }\r\n}\r\n\r\nexport const abrReadContent=(abrSdv:SequentialDataView):AbrHeader=>{\r\n    const abrHeader:AbrHeader = { count: 0, subversion: 0, version: 0 };\r\n    abrHeader.version = abrSdv.getUint16();\r\n    abrHeader.subversion = 0;\r\n    abrHeader.count = 0;\r\n\r\n    switch (abrHeader.version) {\r\n    case 1:\r\n    case 2:\r\n        // ver:1-2\r\n        abrHeader.count = abrSdv.getUint16();\r\n        break;\r\n    case 6:\r\n        // ver:6\r\n        abrHeader.subversion = abrSdv.getUint16();\r\n        abrHeader.count = findSampleCountV6(abrSdv, abrHeader);\r\n        break;\r\n    default:\r\n        // unknown versions\r\n        break;\r\n    }\r\n\r\n    // next bytes in abr are samples data\r\n    return abrHeader;\r\n};\r\n\r\nfunction findSampleCountV6(abrSdv: SequentialDataView, abrHeader: AbrHeader): number {\r\n    let brushSize:number;\r\n    let brushEnd:number;\r\n\r\n    if (!abrSupportedContent(abrHeader))\r\n        return 0;\r\n    const origin = abrSdv.getPos();\r\n    try {\r\n        abrReach8BimSection(abrSdv, 'samp');\r\n    } catch (error) {\r\n        abrSdv.setPos(origin);\r\n        return 0;\r\n    }\r\n    // long\r\n    const sampleSectionSize = abrSdv.getUint32();\r\n    const sampleSectionEnd = sampleSectionSize + abrSdv.getPos();\r\n    if(sampleSectionEnd < 0 || sampleSectionEnd > abrSdv.size())\r\n        return 0;\r\n    const dataStart = abrSdv.getPos();\r\n    let samples = 0;\r\n    while ((!abrSdv.atEnd()) && (abrSdv.getPos() < sampleSectionEnd)) {\r\n        // read long\r\n        brushSize = abrSdv.getUint32();\r\n        brushEnd = brushSize;\r\n        // complement to 4\r\n        while (brushEnd % 4 != 0) brushEnd++;\r\n        const newPos = abrSdv.getPos() + brushEnd;\r\n        if(newPos > 0 && newPos < abrSdv.size()) {\r\n            abrSdv.setPos(newPos);\r\n        }\r\n        else\r\n            return 0;\r\n        samples++;\r\n    }\r\n    // set StreamDataViewer to samples data\r\n    abrSdv.setPos(dataStart);\r\n    return samples;\r\n}\r\n\r\nexport function abrSupportedContent(abrHeader: AbrHeader): boolean {\r\n    switch (abrHeader.version) {\r\n    case 1:\r\n    case 2:\r\n        return true;\r\n    case 6:\r\n        if (abrHeader.subversion == 1 || abrHeader.subversion == 2)\r\n            return true;\r\n        break;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport function abrReach8BimSection(abrSdv: SequentialDataView, name: string):void {\r\n    let sectionSize = 0;\r\n    // find 8BIMname section\r\n    while (!abrSdv.atEnd()) {\r\n        const tag: number[] = [];\r\n        const tagname: number[] = [];\r\n        let r;\r\n        r = abrSdv.readRawData(tag, 4);\r\n        if (r != 4) {\r\n            throw new Error('Error: Cannot read 8BIM tag ');\r\n        }\r\n        if (charCodeComparison(tag, '8BIM', 4)) {\r\n            throw new Error(`Error: Start tag not 8BIM but ${String.fromCharCode(...tag)} at position ${abrSdv.getPos()}`);\r\n        }\r\n        r = abrSdv.readRawData(tagname, 4);\r\n        if (r != 4) {\r\n            throw new Error('Error: Cannot read 8BIM tag name');\r\n        }\r\n        const s1: string = String.fromCharCode(...tagname);\r\n        if (s1 == name) {\r\n            return;\r\n        }\r\n        // long\r\n        sectionSize = abrSdv.getUint32();\r\n        abrSdv.setPos(abrSdv.getPos() + sectionSize);\r\n    }\r\n    return;\r\n}\r\n\r\nexport function charCodeComparison(buffer: number[], str: string, num: number): boolean {\r\n    if ((buffer.length < num) || (str.length < num)) return true;\r\n    for (let i = 0; i < num; i++) {\r\n        if (str.charCodeAt(i) !== buffer[i]) return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport async function loadAbrBrush(abrSdv: SequentialDataView, abrHeader: AbrHeader, filename: string, imageId: number, id: number){\r\n    let layerId = -1;\r\n    switch (abrHeader.version) {\r\n    case 1:\r\n        // fall through, version 1 and 2 are compatible\r\n    case 2:\r\n        layerId = await loadAbrBrushV12(abrSdv, abrHeader, filename, imageId, id);\r\n        break;\r\n    case 6:\r\n        layerId = await loadAbrBrushV6(abrSdv, abrHeader, filename, imageId, id);\r\n        break;\r\n    }\r\n    return layerId;\r\n}\r\n\r\nasync function loadAbrBrushV6(abrSdv: SequentialDataView, abrHeader: AbrHeader, filename: string, imageId: number, id: number): Promise<number> {\r\n    let brushSize = 0;\r\n    let brushEnd = 0;\r\n    let layerId = -1;\r\n\r\n    brushSize = abrSdv.getUint32();\r\n    brushEnd = brushSize;\r\n    // complement to 4\r\n    while (brushEnd % 4 != 0) {\r\n        brushEnd++;\r\n    }\r\n    const nextBrush = abrSdv.getPos() + brushEnd;\r\n    // discard key\r\n    abrSdv.setPos(abrSdv.getPos() + 37);\r\n    if (abrHeader.subversion == 1)\r\n        // discard short coordinates and unknown short\r\n        abrSdv.setPos(abrSdv.getPos() + 10);\r\n    else {\r\n        // discard unknown bytes\r\n        abrSdv.setPos(abrSdv.getPos() + 264);\r\n    }\r\n    // long bounds\r\n    const top = abrSdv.getUint32();\r\n    const left = abrSdv.getUint32();\r\n    const bottom = abrSdv.getUint32();\r\n    const right = abrSdv.getUint32();\r\n    // short\r\n    const depth = abrSdv.getUint16();\r\n    // char\r\n    const compression = abrSdv.getUint8();\r\n    const width = right - left;\r\n    const height = bottom - top;\r\n    const size = width * (depth >> 3) * height;\r\n    // remove .abr and add some id, so something like test.abr . test_12345\r\n    const name: string = abrV1BrushName(filename, id);\r\n    const buffer:number[] = [];\r\n    // data decoding\r\n    if (!compression) {\r\n        // not compressed - read raw bytes as brush data\r\n        abrSdv.readRawData(buffer, size);\r\n    } else {\r\n        rleDecode(abrSdv, buffer, height);\r\n    }\r\n    if (width < INT16_MAX && height < INT16_MAX) {\r\n        // [filename]_[test number of the brush], e.g test_1, test_2\r\n        let abrBrush: AbrSampledBrush;\r\n        const brushTipImage = convertCanvas(buffer, width, height);\r\n        if (Object.keys(abrBrushes.map).includes(name)) {\r\n            abrBrush = getDefaultSampledBrush(name);\r\n        }\r\n        else {\r\n            abrBrush = getDefaultSampledBrush(name);\r\n            const buf = new SequentialDataView(new ArrayBuffer(0));\r\n            abrBrush = { ...abrBrush, md5Sum: await crypto.subtle.digest('SHA-256', buf.data()) };\r\n        }\r\n        abrBrush = { ...abrBrush, brushTipImage };\r\n        abrBrush = { ...abrBrush, valid: true };\r\n        abrBrush = { ...abrBrush, name };\r\n        abrBrushes.set(name, abrBrush);\r\n    }\r\n    abrSdv.setPos(nextBrush);\r\n    layerId = id;\r\n    return layerId;\r\n}\r\n\r\nasync function loadAbrBrushV12(abrSdv: SequentialDataView, abrHeader: AbrHeader, filename: string, imageId: number, id: number): Promise<number> {\r\n    let name = '';\r\n    let layerId = -1;\r\n\r\n    // short\r\n    const brushType = abrSdv.getUint16();\r\n    // long\r\n    const brushSize = abrSdv.getUint32();\r\n    const nextBrush = abrSdv.getPos() + brushSize;\r\n    if (brushType == 1) {\r\n        // computed brush\r\n        abrSdv.setPos(abrSdv.getPos() + 4); //miscellaneous Long integer. Ignored\r\n        const spacing = abrSdv.getUint16(); // 2 bytes Short integer from 0...999 where 0=no spacing.\r\n        const diameter = abrSdv.getUint16(); // 2 bytes Short integer from 1...999.\r\n        const roundness = abrSdv.getUint16(); // 2 bytes Short integer from 0...100.\r\n        const angle = abrSdv.getInt16(); // 2 bytes Short integer from -180...180.\r\n        const hardness = abrSdv.getUint16(); // 2 bytes Short integer from 0...100.\r\n        name = abrV1BrushName(filename, id);\r\n        abrBrushes.set(name, { brushType: brushType, spacing, diameter, roundness, angle, hardness, name });\r\n        abrSdv.setPos(nextBrush);\r\n        layerId = 1;\r\n    }\r\n    else if (brushType == 2) {\r\n        // sampled brush\r\n        // discard 4 misc bytes\r\n        abrSdv.setPos(abrSdv.getPos() + 4);\r\n        const spacing = abrSdv.getUint16();\r\n        if (abrHeader.version == 2)\r\n            name = readAbrUcs2Text(abrSdv);\r\n        if (name === null) {\r\n            name = abrV1BrushName(filename, id);\r\n        }\r\n        const antiAliasing = !!abrSdv.getUint8();\r\n        // discard 4 short for short bounds\r\n        abrSdv.setPos(abrSdv.getPos() + 8);\r\n        // long bounds\r\n        const top = abrSdv.getUint32();\r\n        const left = abrSdv.getUint32();\r\n        const bottom = abrSdv.getUint32();\r\n        const right = abrSdv.getUint32();\r\n        // short\r\n        const depth = abrSdv.getUint16();\r\n        // char\r\n        const compression = abrSdv.getUint8();\r\n        const width = right - left;\r\n        const height = bottom - top;\r\n        const size = width * (depth >> 3) * height;\r\n        // FIXME: support wide brushes\r\n        if (height > 16384) {\r\n            console.warn('WARNING: wide brushes not supported');\r\n            abrSdv.setPos(nextBrush);\r\n        }\r\n        else {\r\n            const buffer: number[] = [];\r\n            if (!compression) {\r\n                // not compressed - read raw bytes as brush data\r\n                abrSdv.readRawData(buffer, size);\r\n            } else {\r\n                rleDecode(abrSdv, buffer, height);\r\n            }\r\n            let abrBrush: AbrSampledBrush;\r\n            const brushTipImage = convertCanvas(buffer, width, height);\r\n            if (Object.keys(abrBrushes.map).includes(name)) {\r\n                abrBrush = getDefaultSampledBrush(name);\r\n            }\r\n            else {\r\n                abrBrush = getDefaultSampledBrush(name);\r\n                const buf = new SequentialDataView(new ArrayBuffer(0));\r\n                // FIXME: it should use a slice containing the brush sample to be useful\r\n                abrBrush = { ...abrBrush, md5Sum: await crypto.subtle.digest('SHA-256', buf.data()) };\r\n            }\r\n            abrBrush = { ...abrBrush, brushTipImage };\r\n            abrBrush = { ...abrBrush, valid: true };\r\n            abrBrush = { ...abrBrush, name, spacing, antiAliasing };\r\n            abrBrushes.set(name, abrBrush);\r\n            layerId = 1;\r\n        }\r\n    }\r\n    else {\r\n        console.warn('Unknown ABR brush type, skipping.');\r\n        abrSdv.setPos(nextBrush);\r\n    }\r\n    return layerId;\r\n}\r\n\r\nfunction abrV1BrushName(filename: string, id: number): string {\r\n    const result = filename.split('');\r\n    const pos = filename.lastIndexOf('.');\r\n    result.splice(pos, 4);\r\n    return result.join('') + '_' + id;\r\n}\r\n\r\nfunction rleDecode(abrSdv: SequentialDataView, data: number[], height: number) {\r\n    // read compressed size foreach scan line\r\n    const scanLines = Array.from({ length: height }, () => 0);\r\n    for (let i = 0; i < height; i++) {\r\n        // short\r\n        scanLines[i] = abrSdv.getUint16();\r\n    }\r\n    // unpack each scan line data\r\n    for (let i = 0; i < height; i++) {\r\n        for (let j = 0; j < scanLines[i];) {\r\n            // char\r\n            if (abrSdv.atEnd()) {\r\n                break;\r\n            }\r\n            let n = abrSdv.getUint8();\r\n            j++;\r\n            if (n >= 128) // force sign\r\n                n -= 256;\r\n            if (n < 0) { // copy the following char -n + 1 times\r\n                if (n == -128) // it's a nop\r\n                    continue;\r\n                n = -n + 1;\r\n                // char\r\n                const ch = abrSdv.getUint8();\r\n                if (abrSdv.atEnd()) {\r\n                    break;\r\n                }\r\n                j++;\r\n                for (let k = 0; k < n; k++) {\r\n                    data.push(ch);\r\n                }\r\n            }\r\n            else {\r\n                // read the following n + 1 chars (no compr)\r\n                for (let c = 0; c < n + 1; c++, j++) {\r\n                    // char\r\n                    const ct = abrSdv.getUint8();\r\n                    data.push(ct);\r\n                    //data.pos++;\r\n                    if (abrSdv.atEnd()) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction convertCanvas(buffer: number[], width: number, height: number): HTMLCanvasElement {\r\n    const img = document.createElement('canvas');\r\n    img.width = width;\r\n    img.height = height;\r\n    const ctx = img.getContext('2d');\r\n    if (!ctx) throw new Error('Failed to construct context.');\r\n    const pixel = ctx.getImageData(0, 0, width, height);\r\n    let pos = 0;\r\n    let value = 0;\r\n    for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++, pos++) {\r\n            value = 255 - buffer[pos];\r\n            for (let i = 0; i < 3; i++) {\r\n                pixel.data[y * width * 4 + x * 4 + i] = value;\r\n            }\r\n            pixel.data[y * width * 4 + x * 4 + 3] = 255;\r\n        }\r\n    }\r\n    ctx.putImageData(pixel, 0, 0);\r\n    return img;\r\n}\r\n\r\nfunction readAbrUcs2Text(abrSdv: SequentialDataView): string {\r\n    let i: number;\r\n    /* two-bytes characters encoded (UCS-2)\r\n    *  format:\r\n    *   long : size - number of characters in string\r\n    *   data : zero terminated UCS-2 string\r\n    */\r\n    // long\r\n    const nameSize = abrSdv.getUint32();\r\n    if (nameSize == 0) {\r\n        return '';\r\n    }\r\n    const bufSize = nameSize;\r\n    const nameUcs2: number[] = [];\r\n    for (i = 0; i < bufSize; i++) {\r\n        //* char*/\r\n        // I will use uint16 as that is input to fromUtf16\r\n        nameUcs2[i] = abrSdv.getUint16();\r\n    }\r\n    const nameUtf8 = String.fromCharCode(...nameUcs2);\r\n    return nameUtf8;\r\n}"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","t","constructor","dataView","DataView","offset","readRawData","s","length","pop","i","h","atEnd","push","getUint8","data","buffer","getPos","setPos","size","byteLength","getUint16","getUint32","getInt16","getChar","String","fromCharCode","INT16_MAX","defaultBrushTipImage","document","createElement","abrBrushes","map","set","clear","list","values","getDefaultSampledBrush","name","brushType","brushTipImage","md5Sum","ArrayBuffer","valid","spacing","antiAliasing","loadAbrBrushes","file","loadAbrFromArrayBuffer","Promise","resolve","reject","fileReader","FileReader","onload","event","target","result","readAsArrayBuffer","filename","abrSdv","abrHeader","abrReadContent","abrSupportedContent","Error","version","subversion","count","loadAbrBrush","imageId","console","warn","brushes","error","brushSize","brushEnd","origin","abrReach8BimSection","sampleSectionEnd","dataStart","samples","newPos","findSampleCountV6","sectionSize","tag","tagname","r","charCodeComparison","str","num","charCodeAt","id","layerId","nextBrush","diameter","roundness","angle","hardness","abrV1BrushName","nameSize","bufSize","nameUcs2","readAbrUcs2Text","top","left","bottom","right","depth","compression","width","height","abrBrush","rleDecode","convertCanvas","keys","includes","buf","crypto","subtle","digest","loadAbrBrushV12","loadAbrBrushV6","split","pos","lastIndexOf","splice","join","scanLines","Array","from","j","n","ch","k","c","ct","img","ctx","getContext","pixel","getImageData","y","x","putImageData"],"sourceRoot":""}